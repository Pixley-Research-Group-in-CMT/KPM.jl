<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · KPM.jl</title><link rel="canonical" href="https://yixingfu.github.io/KPM.jl/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">KPM.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Moment-calculation"><span>Moment calculation</span></a></li><li class="toplevel"><a class="tocitem" href="#applications"><span>applications</span></a></li><li><a class="tocitem" href="#DOS"><span>DOS</span></a></li><li class="toplevel"><a class="tocitem" href="#Kernels"><span>Kernels</span></a></li><li class="toplevel"><a class="tocitem" href="#full-API-reference"><span>full API reference</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/yixingfu/KPM.jl/blob/master/docs/src/index.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="KPM"><a class="docs-heading-anchor" href="#KPM">KPM</a><a id="KPM-1"></a><a class="docs-heading-anchor-permalink" href="#KPM" title="Permalink"></a></h1><ul><li><a href="#KPM.JacksonKernel"><code>KPM.JacksonKernel</code></a></li><li><a href="#KPM.JacksonKernel-Tuple{Integer,Integer}"><code>KPM.JacksonKernel</code></a></li><li><a href="#KPM.LorentzKernels"><code>KPM.LorentzKernels</code></a></li><li><a href="#KPM.LorentzKernels-Tuple{Float64}"><code>KPM.LorentzKernels</code></a></li><li><a href="#KPM.broadcast_dot_1d_1d!"><code>KPM.broadcast_dot_1d_1d!</code></a></li><li><a href="#KPM.broadcast_dot_2d_1d!-Tuple{Array{T,2} where T,Array{T,3} where T,Array{T,2} where T,Int64,Int64}"><code>KPM.broadcast_dot_2d_1d!</code></a></li><li><a href="#KPM.broadcast_dot_reduce_avg_2d_1d!-Tuple{Array{T,1} where T,Array{T,1} where T&lt;:(SubArray{Ts,2,P,I,L} where L where I where P where Ts),Array{T,2} where T,Int64,Int64}"><code>KPM.broadcast_dot_reduce_avg_2d_1d!</code></a></li><li><a href="#KPM.chebyshev_iter-Tuple{Any,Union{CUDA.CuArray{T,2}, Array{T,2}} where T,Int64}"><code>KPM.chebyshev_iter</code></a></li><li><a href="#KPM.dos"><code>KPM.dos</code></a></li><li><a href="#KPM.dos0"><code>KPM.dos0</code></a></li><li><a href="#KPM.fermiFunction-Tuple{Float64,Float64,Float64}"><code>KPM.fermiFunction</code></a></li><li><a href="#KPM.fermiFunctions-Tuple{Float64,Float64}"><code>KPM.fermiFunctions</code></a></li><li><a href="#KPM.isNotBoundary-NTuple{4,Any}"><code>KPM.isNotBoundary</code></a></li><li><a href="#KPM.kpm_1d"><code>KPM.kpm_1d</code></a></li><li><a href="#KPM.kpm_1d!"><code>KPM.kpm_1d!</code></a></li><li><a href="#KPM.kpm_2d"><code>KPM.kpm_2d</code></a></li><li><a href="#KPM.kpm_2d!"><code>KPM.kpm_2d!</code></a></li><li><a href="#KPM.normalizeH-Tuple{SparseArrays.SparseMatrixCSC{Complex{Float64},Int64}}"><code>KPM.normalizeH</code></a></li><li><a href="#KPM.normalize_by_col-Tuple{Any,Any}"><code>KPM.normalize_by_col</code></a></li><li><a href="#KPM.wrapAdd-Tuple{Int64,Int64,Int64}"><code>KPM.wrapAdd</code></a></li></ul><h1 id="Moment-calculation"><a class="docs-heading-anchor" href="#Moment-calculation">Moment calculation</a><a id="Moment-calculation-1"></a><a class="docs-heading-anchor-permalink" href="#Moment-calculation" title="Permalink"></a></h1><p>The first step in KPM is calculating moments using Hamiltonians (and current operators for conductivity etc.) Functions with <code>!</code> are more efficient in-place version; those without <code>!</code> are convenient methods based on the in-place methods.</p><article class="docstring"><header><a class="docstring-binding" id="KPM.kpm_1d" href="#KPM.kpm_1d"><code>KPM.kpm_1d</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">kpm_1d(H, NC, NR; kwargs...)</code></pre><p>defined at <a href="https://github.com/yixingfu/KPM.jl/tree/a540d3cd7ad4d82de5dcb1998524c47e36f44a53//src/moment.jl#L178"><code>/home/runner/work/KPM.jl/KPM.jl/src/moment.jl:178</code></a>.</p><pre><code class="language-julia">kpm_1d(H, NC, NR, NH; psi_in, psi_in_l, psi_in_r, force_norm, verbose, avg_output)</code></pre><p>defined at <a href="https://github.com/yixingfu/KPM.jl/tree/a540d3cd7ad4d82de5dcb1998524c47e36f44a53//src/moment.jl#L179"><code>/home/runner/work/KPM.jl/KPM.jl/src/moment.jl:179</code></a>.</p><p>The simple version of 1D KPM that returns the moment.</p><ul><li><p><code>H</code>           – Hamiltonian. A matrix or sparse matrix</p></li><li><p><code>NC</code>          – Integer. the cut off dimension</p></li><li><p><code>NR</code>          – Integer. number of random vectors used for KPM evaluation</p></li><li><p><code>NH</code>          – Integer. the size of hamiltonian</p></li><li><p><code>psi_in</code>      – Optional. Allow setting random vector manually.</p></li><li><p><code>force_norm</code>  – Boolean, Optional. Apply normalization.</p></li><li><p><code>verbose</code>     – Integer. Default is 0. Enables progress bar if set <code>verbose=1</code>.</p></li><li><p><code>avg_output</code>  – Boolean. Default is true. Whether to output averaged μ (hence size NC) or separate μs (size NR x NC).</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/yixingfu/KPM.jl/blob/a540d3cd7ad4d82de5dcb1998524c47e36f44a53/src/moment.jl#LL26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="KPM.kpm_1d!" href="#KPM.kpm_1d!"><code>KPM.kpm_1d!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">kpm_1d!(H, NC, NR, NH, mu_all, psi_in; verbose, α_all)</code></pre><p>defined at <a href="https://github.com/yixingfu/KPM.jl/tree/a540d3cd7ad4d82de5dcb1998524c47e36f44a53//src/moment.jl#L219"><code>/home/runner/work/KPM.jl/KPM.jl/src/moment.jl:219</code></a>.</p><pre><code class="language-julia">kpm_1d!(H, NC, NR, NH, mu; kwargs...)</code></pre><p>defined at <a href="https://github.com/yixingfu/KPM.jl/tree/a540d3cd7ad4d82de5dcb1998524c47e36f44a53//src/moment.jl#L278"><code>/home/runner/work/KPM.jl/KPM.jl/src/moment.jl:278</code></a>.</p><pre><code class="language-julia">kpm_1d!(H, NC, NR, NH, mu, psi_in_l, psi_in_r; kwargs...)</code></pre><p>defined at <a href="https://github.com/yixingfu/KPM.jl/tree/a540d3cd7ad4d82de5dcb1998524c47e36f44a53//src/moment.jl#L287"><code>/home/runner/work/KPM.jl/KPM.jl/src/moment.jl:287</code></a>.</p><p>The in-place version of 1D KPM.  Calculate the moments μ defined in KPM. Output is saved in <code>mu</code>.</p><ul><li><p><code>H</code>           – Hamiltonian. A matrix or sparse matrix.</p></li><li><p><code>NC</code>          – Integer. the cut off dimension.</p></li><li><p><code>NR</code>          – Integer. number of random vectors used for KPM evaluation.</p></li><li><p><code>NH</code>          – Integer. the size of hamiltonian.</p></li><li><p><code>mu_all</code>          – Array. Output for each random vector. Size (NR, NC). </p></li><li><p><code>psi_in</code>      – Array (optional). Input array on the right side. A ket.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/yixingfu/KPM.jl/blob/a540d3cd7ad4d82de5dcb1998524c47e36f44a53/src/moment.jl#LL5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="KPM.kpm_2d" href="#KPM.kpm_2d"><code>KPM.kpm_2d</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">kpm_2d(H, Ja, Jb, NC, NR, NH; psi_in, psi_in_l, psi_in_r, kwargs...)</code></pre><p>defined at <a href="https://github.com/yixingfu/KPM.jl/tree/a540d3cd7ad4d82de5dcb1998524c47e36f44a53//src/moment.jl#L299"><code>/home/runner/work/KPM.jl/KPM.jl/src/moment.jl:299</code></a>.</p><p>The simple version of 2D KPM that returns the moment. Calculate moments for 2D KPM. </p><p>Calculates <code>ψ0l * Tm(H) * Jβ * Tn(H) * Jα * ψ0r</code>. When ψ0r and ψ0l are chosen to be random and identical, the output approximates tr(Tm(H) Jβ Tn(H) Jα). The accuracy is ~ O(1/sqrt(NR * NH)). NC controls the energy resolution of the result.</p><p>Output: μ, a 2D array in ComplexF64. μ[n, m] is the momentum for 2D KPM.</p><p><strong>ARGS</strong></p><ul><li><code>H</code></li></ul><p>Hamiltonian. A sparse 2D array.</p><ul><li><code>Jα</code></li></ul><p>Current operator. A sparse 2D array.</p><ul><li><code>Jβ</code></li></ul><p>Current operator. A sparse 2D array.</p><ul><li><code>NC</code></li></ul><p>Integer. KPM cutoff order.</p><ul><li><code>NR</code></li></ul><p>Integer. Number of random vectors to choose from. When skipped, understood as NR=1.</p><ul><li><code>NH</code></li></ul><p>Integer. Dimension of H, Jα and Jβ</p><p><strong>KWARGS</strong></p><ul><li><code>psi_in_l</code></li></ul><p>Passes value to ψ0l. The array is not updated. Size should be (NH, NR) (preferred) or (NR, NH) if set.</p><ul><li><code>psi_in_r</code></li></ul><p>Passes value to ψ0r. The array is not updated. Size should be  (NH, NR) (preferred) or (NR, NH) if set.</p><ul><li><code>psi_in</code></li></ul><p>Cannot be used together with psi<em>in</em>l and psi<em>in</em>r. Sets psi<em>in</em>l=psi<em>in</em>r=psi_in if set.</p><ul><li><code>kwargs</code></li></ul><p>other kwargs in KPM_2D!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/yixingfu/KPM.jl/blob/a540d3cd7ad4d82de5dcb1998524c47e36f44a53/src/moment.jl#LL119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="KPM.kpm_2d!" href="#KPM.kpm_2d!"><code>KPM.kpm_2d!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">kpm_2d!(H, Jα, Jβ, NC, NR, NH, μ, psi_in_l, psi_in_r; arr_size, verbose, ψ0r, Jψ0r, JTnHJψr, ψall_r, ψ0l, ψall_l, ψw)</code></pre><p>defined at <a href="https://github.com/yixingfu/KPM.jl/tree/a540d3cd7ad4d82de5dcb1998524c47e36f44a53//src/moment.jl#L310"><code>/home/runner/work/KPM.jl/KPM.jl/src/moment.jl:310</code></a>.</p><pre><code class="language-julia">kpm_2d!(H, Jα, Jβ, NC, NR, NH, μ, psi_in; kwargs...)</code></pre><p>defined at <a href="https://github.com/yixingfu/KPM.jl/tree/a540d3cd7ad4d82de5dcb1998524c47e36f44a53//src/moment.jl#L402"><code>/home/runner/work/KPM.jl/KPM.jl/src/moment.jl:402</code></a>.</p><pre><code class="language-julia">kpm_2d!(H, Jα, Jβ, NC, NR, NH, μ; kwargs...)</code></pre><p>defined at <a href="https://github.com/yixingfu/KPM.jl/tree/a540d3cd7ad4d82de5dcb1998524c47e36f44a53//src/moment.jl#L412"><code>/home/runner/work/KPM.jl/KPM.jl/src/moment.jl:412</code></a>.</p><p>In place KPM2D. This is also the main building block for KPM_2D. This method only provide NR=1.</p><p>Calculates <code>ψ0l * Tm(H) * Jβ * Tn(H) * Jα * ψ0r</code>.  When <code>ψ0r</code> and <code>ψ0l</code> are chosen to be random and identical, the output approximates <code>tr(Tm(H) Jβ Tn(H) Jα)</code>. The accuracy is <span>$\sim O(1/sqrt(NR * NH))$</span> with NR repetitions. NC controls the energy resolution of the result.</p><p>Output: nothing. Result is saved on μ.</p><p><strong>ARGS</strong></p><ul><li><p><code>H</code> : Hamiltonian. A sparse 2D array.</p></li><li><p><code>Jα</code> : Current operator. A sparse 2D array.</p></li><li><p><code>Jβ</code> : Current operator. A sparse 2D array.</p></li><li><p><code>NC</code> : Integer. KPM cutoff order.</p></li><li><p><code>NR</code> : Integer. Number of random vectors.</p></li><li><p><code>NH</code> : Integer. Dimension of H, Jα and Jβ</p></li><li><p><code>μ</code> : 2D Array of dimension (NC, NC). Results will be updated here. Any data</p></li></ul><p>will be overwritten.</p><ul><li><code>psi_in</code> : Set <code>psi_in_l</code> and <code>psi_in_r</code>. Size is (NH, NR). The array is not updated.</li></ul><p>Whether the input is normalized or not, it is assumed to be intended. Usually <code>psi_in</code> should be normalized.</p><ul><li><code>psi_in_l</code> : Passes value to ψ0l. Size is (NH, NR). The array is not updated.</li></ul><p>Whether the input is normalized or not, it is assumed to be intended. Usually <code>psi_in_l</code> should be normalized. <code>psi_in_l</code> is given as column vector of ket <span>$|ψl&gt; = &lt;ψl|^\dagger$</span></p><ul><li><code>psi_in_r</code> : Passes value to ψ0r. Size is (NH, NR). The array is not updated.</li></ul><p>Whether the input is normalized or not, it is assumed to be intended. Usually <code>psi_in_r</code> should be normalized. <code>psi_in_r</code> is given as column vector of ket <span>$|ψr&gt;$</span>. </p><p><strong>KWARGS</strong></p><ul><li><code>arr_size</code> : The buffer array size. Minimum is 3. Determines the number of</li></ul><p>left states to be kept in memory for each loop of right states. The time complexity is reduced from <span>$O(N\times NC^2)$</span> to <span>$O(N\times NC\times arr\_size)$</span> while space complexity is increased from <span>$O(N\times NC)$</span> to <span>$O(N\times NC\times arr\_size)$</span>.</p><p><strong>working spaces KWARGS</strong>: The following keyword args are simply providing working place arrays to avoid repetitive allocation and GC. They are automatically created if not set. However, when using <code>KPM_2D!</code> for many times, it is beneficial to reuse those arrays.  CONVENTION: args with <code>ψ</code> are all working space arr.</p><ul><li><code>ψ0r=maybe_on_device_zeros(NH, NR)</code></li><li><code>Jψ0r=maybe_on_device_zeros(NH, NR)</code></li><li><code>JTnHJψr=maybe_on_device_zeros(NH, NR)</code></li><li><code>ψall_r=maybe_on_device_zeros(3, NH, NR)</code></li><li><code>ψ0l=maybe_on_device_zeros(NH, NR)</code></li><li><code>ψall_l=maybe_on_device_zeros(arr_size, NH, NR)</code></li><li><code>ψw=maybe_on_device_zeros(NH, NR)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/yixingfu/KPM.jl/blob/a540d3cd7ad4d82de5dcb1998524c47e36f44a53/src/moment.jl#LL50">source</a></section></article><h1 id="applications"><a class="docs-heading-anchor" href="#applications">applications</a><a id="applications-1"></a><a class="docs-heading-anchor-permalink" href="#applications" title="Permalink"></a></h1><h2 id="DOS"><a class="docs-heading-anchor" href="#DOS">DOS</a><a id="DOS-1"></a><a class="docs-heading-anchor-permalink" href="#DOS" title="Permalink"></a></h2><p>To calculate density of state (DOS), first calculating moment first using <code>kpm_1d</code> or <code>kpm_1d!</code> with default (random) input vectors. Then use the output (moment <code>mu</code>) to calculate density of state.  There is also an option to pass Hamiltonian directly to <code>dos</code>, which does the moment calculation automatically.</p><article class="docstring"><header><a class="docstring-binding" id="KPM.dos" href="#KPM.dos"><code>KPM.dos</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dos(H; NC, NR, E_grid, N_tilde, E_range, kernel, fix_normalization)</code></pre><p>defined at <a href="https://github.com/yixingfu/KPM.jl/tree/a540d3cd7ad4d82de5dcb1998524c47e36f44a53//src/applications/dos.jl#L31"><code>/home/runner/work/KPM.jl/KPM.jl/src/applications/dos.jl:31</code></a>.</p><pre><code class="language-julia">dos(μ, H_rescale_factor; E_grid, N_tilde, E_range, NC, kernel)</code></pre><p>defined at <a href="https://github.com/yixingfu/KPM.jl/tree/a540d3cd7ad4d82de5dcb1998524c47e36f44a53//src/applications/dos.jl#L48"><code>/home/runner/work/KPM.jl/KPM.jl/src/applications/dos.jl:48</code></a>.</p><p>Calculate DOS for a fermi energy grid spanning <code>E_range</code> with <code>N_tilde</code> total points. If <code>E_range</code> is not set,  automatically set it to be sightly smaller than full size. Otherwise an explicit array of <code>E_grid</code> can be passed in. Don&#39;t do both.</p><p>Either a) pass in a 1d array as moment and  as normalization factor;  or b) pass in a Hamiltonian that is rescaled with an optional keyword <code>rescale_factor</code> that default to 1.</p><ul><li><p><code>H_rescale_factor</code> is the normalization of H. Needed when μ is passed.</p></li><li><p><code>NR</code> random vectors. Needed when H is passed</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/yixingfu/KPM.jl/blob/a540d3cd7ad4d82de5dcb1998524c47e36f44a53/src/applications/dos.jl#LL4">source</a></section></article><h1 id="Kernels"><a class="docs-heading-anchor" href="#Kernels">Kernels</a><a id="Kernels-1"></a><a class="docs-heading-anchor-permalink" href="#Kernels" title="Permalink"></a></h1><p>Kernels are functions defined as</p><pre><code class="language-none">kernel(n::Int64, N::Int64) -&gt; Float64</code></pre><p>such that when <code>n==0</code>, returns <code>1</code>; when <code>n==N-1</code>, returns small number close to <code>0</code>.</p><p>We implement JacksonKernel and LorentzKernels in the package. Jackson Kernel is the default kernel for most application.</p><article class="docstring"><header><a class="docstring-binding" id="KPM.JacksonKernel" href="#KPM.JacksonKernel"><code>KPM.JacksonKernel</code></a> — <span class="docstring-category">Function</span></header><section><div><p>JacksonKernel(n::Integer, N::Integer)</p><p>Jacksonkernel evaluated at n-th expansion coefficient with N in total (NC)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/yixingfu/KPM.jl/blob/a540d3cd7ad4d82de5dcb1998524c47e36f44a53/src/kernels/jackson_kernel.jl#LL2-L6">source</a></section></article><p>Lorentz Kernel is good for Green functions as it respects symmetry. The function <code>LorentzKernels</code> takes parameter λ and returns a kernel function.</p><article class="docstring"><header><a class="docstring-binding" id="KPM.LorentzKernels" href="#KPM.LorentzKernels"><code>KPM.LorentzKernels</code></a> — <span class="docstring-category">Function</span></header><section><div><p>LorentzKernels(λ::Float64)</p><p>Returns function LorentzKernel(n, N) that evaluates Lorentz kernel with parameter λ, at n-th expansion coefficient with N in total (NC)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/yixingfu/KPM.jl/blob/a540d3cd7ad4d82de5dcb1998524c47e36f44a53/src/kernels/lorentz_kernel.jl#LL2-L6">source</a></section></article><h1 id="full-API-reference"><a class="docs-heading-anchor" href="#full-API-reference">full API reference</a><a id="full-API-reference-1"></a><a class="docs-heading-anchor-permalink" href="#full-API-reference" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="KPM.JacksonKernel-Tuple{Integer,Integer}" href="#KPM.JacksonKernel-Tuple{Integer,Integer}"><code>KPM.JacksonKernel</code></a> — <span class="docstring-category">Method</span></header><section><div><p>JacksonKernel(n::Integer, N::Integer)</p><p>Jacksonkernel evaluated at n-th expansion coefficient with N in total (NC)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/yixingfu/KPM.jl/blob/a540d3cd7ad4d82de5dcb1998524c47e36f44a53/src/kernels/jackson_kernel.jl#LL2-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="KPM.LorentzKernels-Tuple{Float64}" href="#KPM.LorentzKernels-Tuple{Float64}"><code>KPM.LorentzKernels</code></a> — <span class="docstring-category">Method</span></header><section><div><p>LorentzKernels(λ::Float64)</p><p>Returns function LorentzKernel(n, N) that evaluates Lorentz kernel with parameter λ, at n-th expansion coefficient with N in total (NC)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/yixingfu/KPM.jl/blob/a540d3cd7ad4d82de5dcb1998524c47e36f44a53/src/kernels/lorentz_kernel.jl#LL2-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="KPM.broadcast_dot_1d_1d!" href="#KPM.broadcast_dot_1d_1d!"><code>KPM.broadcast_dot_1d_1d!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Vl and Vr are both [NH, NR] sized array. Each corresponding [:, NR] slice pair is dotted, saving into the target of [NR], multiplying by alpha and plus beta. Beta is either a number or vector of [NR]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/yixingfu/KPM.jl/blob/a540d3cd7ad4d82de5dcb1998524c47e36f44a53/src/utils/vectors.jl#LL92-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="KPM.broadcast_dot_2d_1d!-Tuple{Array{T,2} where T,Array{T,3} where T,Array{T,2} where T,Int64,Int64}" href="#KPM.broadcast_dot_2d_1d!-Tuple{Array{T,2} where T,Array{T,3} where T,Array{T,2} where T,Int64,Int64}"><code>KPM.broadcast_dot_2d_1d!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Dot product each column of Vls with vector Vr, save in target.</p><p>target: 2D Array (n, NR), n &gt;= ncols. Vls: 3D Array, shape (NH, NR, n), where n &gt;= ncols. Vr: 2D Array, shape NH, NR ncols: Integer, number of columns. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/yixingfu/KPM.jl/blob/a540d3cd7ad4d82de5dcb1998524c47e36f44a53/src/utils/vectors.jl#LL17-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="KPM.broadcast_dot_reduce_avg_2d_1d!-Tuple{Array{T,1} where T,Array{T,1} where T&lt;:(SubArray{Ts,2,P,I,L} where L where I where P where Ts),Array{T,2} where T,Int64,Int64}" href="#KPM.broadcast_dot_reduce_avg_2d_1d!-Tuple{Array{T,1} where T,Array{T,1} where T&lt;:(SubArray{Ts,2,P,I,L} where L where I where P where Ts),Array{T,2} where T,Int64,Int64}"><code>KPM.broadcast_dot_reduce_avg_2d_1d!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Dot product each column of Vls with vector Vr, save in target. Each view has NR replica of NH. This function take the average.</p><p>target: 1D Array (n), n &gt;= ncols. Vls: 1D Array of 2D views, shape (n), each view (NH, NR), where n &gt;= ncols. Vr: 2D Array, shape NH, NR ncols: Integer, number of columns. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/yixingfu/KPM.jl/blob/a540d3cd7ad4d82de5dcb1998524c47e36f44a53/src/utils/vectors.jl#LL59-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="KPM.chebyshev_iter-Tuple{Any,Union{CUDA.CuArray{T,2}, Array{T,2}} where T,Int64}" href="#KPM.chebyshev_iter-Tuple{Any,Union{CUDA.CuArray{T,2}, Array{T,2}} where T,Int64}"><code>KPM.chebyshev_iter</code></a> — <span class="docstring-category">Method</span></header><section><div><p>evaluate from 3 to n ψall[:,3] comes from ψall[:,2] and ψall[:,1] separating into two function might improve performance (or not???)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/yixingfu/KPM.jl/blob/a540d3cd7ad4d82de5dcb1998524c47e36f44a53/src/utils/chebyshev_iteration.jl#LL3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="KPM.dos0" href="#KPM.dos0"><code>KPM.dos0</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dos0(μ, H_rescale_factor; NC, kernel, dE_order)</code></pre><p>defined at <a href="https://github.com/yixingfu/KPM.jl/tree/a540d3cd7ad4d82de5dcb1998524c47e36f44a53//src/applications/dos.jl#L110"><code>/home/runner/work/KPM.jl/KPM.jl/src/applications/dos.jl:110</code></a>.</p><p>Calculate DOS and its energy derivatives (by setting <code>dE_order</code>) at zero energy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/yixingfu/KPM.jl/blob/a540d3cd7ad4d82de5dcb1998524c47e36f44a53/src/applications/dos.jl#LL22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="KPM.fermiFunction-Tuple{Float64,Float64,Float64}" href="#KPM.fermiFunction-Tuple{Float64,Float64,Float64}"><code>KPM.fermiFunction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fermiFunction(E, E_f, beta)</code></pre><p>calculate Fermi-Dirac function at energy E, Fermi energy μ and temperature β =1/T. Input and output all Float64. Infinite β only allowed when accessing fermi energy through fermiFunctions(). [For performance reason for now. TODO: allow β=Inf here withouth perf. reduction. ]</p><p>Allow sloppy use of type as long as convertion is available, if using keyword arguments. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/yixingfu/KPM.jl/blob/a540d3cd7ad4d82de5dcb1998524c47e36f44a53/src/utils/physics.jl#LL7-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="KPM.fermiFunctions-Tuple{Float64,Float64}" href="#KPM.fermiFunctions-Tuple{Float64,Float64}"><code>KPM.fermiFunctions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fermiFunctions(E_f::Float64, beta::Float64)</code></pre><p>returns a fermi function with given E_f and beta. </p><p>Allow sloppy use of type as long as convertion is available, if using keyword arguments. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/yixingfu/KPM.jl/blob/a540d3cd7ad4d82de5dcb1998524c47e36f44a53/src/utils/physics.jl#LL21-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="KPM.isNotBoundary-NTuple{4,Any}" href="#KPM.isNotBoundary-NTuple{4,Any}"><code>KPM.isNotBoundary</code></a> — <span class="docstring-category">Method</span></header><section><div><p>give 0 for OBC=1 direction if i,i_ is on boundary. Otherwise 1</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/yixingfu/KPM.jl/blob/a540d3cd7ad4d82de5dcb1998524c47e36f44a53/src/utils/external.jl#LL11-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="KPM.normalizeH-Tuple{SparseArrays.SparseMatrixCSC{Complex{Float64},Int64}}" href="#KPM.normalizeH-Tuple{SparseArrays.SparseMatrixCSC{Complex{Float64},Int64}}"><code>KPM.normalizeH</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Normalize H. If requested, allow renormalizing it to fixed value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/yixingfu/KPM.jl/blob/a540d3cd7ad4d82de5dcb1998524c47e36f44a53/src/utils/external.jl#LL20-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="KPM.normalize_by_col-Tuple{Any,Any}" href="#KPM.normalize_by_col-Tuple{Any,Any}"><code>KPM.normalize_by_col</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Normalize a collection of vectors in an (NH, NR) array <code>psi_in</code>, where each column (that is <code>psi_in[:, NRi]</code>) represent a separate vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/yixingfu/KPM.jl/blob/a540d3cd7ad4d82de5dcb1998524c47e36f44a53/src/utils/vectors.jl#LL3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="KPM.wrapAdd-Tuple{Int64,Int64,Int64}" href="#KPM.wrapAdd-Tuple{Int64,Int64,Int64}"><code>KPM.wrapAdd</code></a> — <span class="docstring-category">Method</span></header><section><div><p>wrapAdd find the sum of x and y, with L+1=1</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/yixingfu/KPM.jl/blob/a540d3cd7ad4d82de5dcb1998524c47e36f44a53/src/utils/external.jl#LL3-L5">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 16 December 2020 21:30">Wednesday 16 December 2020</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
